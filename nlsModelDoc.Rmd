---
title: "Understanding nlsModel in the base R nls() function"
author:
  - Arkajyoti Bhattacharjee, Indian Institute of Technology, Kanpur
  - John C. Nash, University of Ottawa, Canada
date: "05/06/2021"
output: pdf_document
bibliography: ImproveNLS.bib
---

<!-- - Heather Turner, University of Warwick, UK -->

# Objective

The R function `nls()` for nonlinear least squares modeling uses a structure where
a "model" object named `m` is built from an expression in the `nls` call. This 
object contains a great deal of functionality in the form of data and functions that
different parts of the `nls` infrastructure can use. In particular, `m` contains
functions to determine if the estimation of the model is "converged" (actually if
the process is "terminated") as well as computations of residuals and the search
direction for the next set of parameters. 

This article is an attempt to document and test the features of the nlsModel object `m`.

# Location of the nlsModel code

The code is found in the file `./R-devel/src/library/stats/R/nls.R` 

Note that there is a version `nlsModel.plinear` for use with partially linear models
(?? a ref would be helpful here). The default case and the use of bounds constraints
using the `algorithm` setting "port" are handled by `nlsModel`. 

Here we will at time of writing (June 2021) only deal with the default case.

# Generating an 'm`' object

Let us use the Croucher problem and/or the Hobbs weed infestation problem (@jncnm79, page 120) again.


```{r croucherex}
# Croucher-example1.R -- https://walkingrandomly.com/?p=5254
# construct the data vectors using c()
xdata = c(-2,-1.64,-1.33,-0.7,0,0.45,1.2,1.64,2.32,2.9)
ydata = c(0.699369,0.700462,0.695354,1.03905,1.97389,2.41143,1.91091,0.919576,-0.730975,-1.42001)

# some starting values
p1 = 1
p2 = 0.2

Cdata<-data.frame(xdata, ydata)

# do the fit
## Try numericDeriv() function
Cform <- ydata ~ p1*cos(p2*xdata) + p2*sin(p1*xdata)
Ctheta<-c("p1","p2")
Cstart<-c(p1=p1, p2=p2)


nmodc1<-nlspkg::nlsModel(form=Cform, data=Cdata, start=Cstart, wts=NULL, upper=NULL, scaleOffset = 0, nDcentral = FALSE)
print(str(nmodc1))

```

```{r hobbsex}
# Data for Hobbs problem
ydat  <-  c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443, 
            38.558, 50.156, 62.948, 75.995, 91.972) # for testing
tdat  <-  seq_along(ydat) # for testing

# A simple starting vector -- must have named parameters for nlxb, nls, wrapnlsr.
start1  <-  c(b1=1, b2=1, b3=1)
eunsc  <-   y ~ b1/(1+b2*exp(-b3*tt))
str(eunsc)
# Can we convert a string form of this "model" to a formula
ceunsc <- " y ~ b1/(1+b2*exp(-b3*tt))"
str(ceunsc)

weeddata1  <-  data.frame(y=ydat, tt=tdat)

## Now ready to try things out.
library(nlsalt) # ?? needed because base R does not export nlsModel()
nmodh1<-nlsModel(form=eunsc, data=weeddata1, start=start1, wts=NULL, upper=NULL, scaleOffset = 0, nDcentral = FALSE)
str(nmodh1)
ls.str(nmodh1)
print(nmodh1)
```

# Examining the nlsModel output

The output of `nlsModel` is an object of class attribute "nlsModel" with 16 elements. (??Is this always the case, 
or can the call cause elements to be added or not produced?)

## resid()

This function computes the residuals in the current environment. (?? Is this .GlobalEnv? Can
that environment be changed i.e., is it an argument to resid()?)

```{r tresid}
cat("Display Croucher residuals from nmodc1 as currently set:\n")
print(nmodc1$resid())
cat("Display Hobbs residuals from nmodc1 as currently set:\n")
print(nmodh1$resid())
```


## fitted()

This function computes the fitted values of the nonlinear model in the current environment.
The output includes an attribute, "gradient", which is actually the Jacobian matrix of which
the k, j element is the 

```{r fitted}
cat("Display Croucher fitted model values from nmodc1 as currently set:\n")
print(nmodc1$fitted())
cat("Display Hobbs fitted model values from nmodc1 as currently set:\n")
print(nmodh1$fitted())
```


##  formula()  

```{r tformula}  
cat("Display Croucher formula from nmodc1 as currently set:\n")
print(nmodc1$formula())
cat("Display Hobbs formula from nmodc1 as currently set:\n")
print(nmodh1$formula())


```



##  deviance()  

```{r tdeviance}  
cat("Display Croucher deviance from nmodc1 as currently set:\n")
print(nmodc1$deviance())
cat("Display Hobbs deviance from nmodc1 as currently set:\n")
print(nmodh1$deviance())
```

##  lhs()  

```{r tlhs}  
cat("Display Croucher lhs from nmodc1 as currently set:\n")
print(nmodc1$lhs())
cat("Display Hobbs lhs from nmodc1 as currently set:\n")
print(nmodh1$lhs())
```

##  gradient()  

```{r tgradient}  
cat("Display Croucher gradient from nmodc1 as currently set:\n")
print(nmodc1$gradient())
cat("Display Hobbs gradient from nmodc1 as currently set:\n")
print(nmodh1$gradient())
```

##  conv()  

```{r tconv}
cat("Display Croucher conv from nmodc1 as currently set:\n")
print(nmodc1$conv())
cat("Display Hobbs conv from nmodc1 as currently set:\n")
print(nmodh1$conv())

```

##  incr()  

```{r tincr}  
cat("Display Croucher incr from nmodc1 as currently set:\n")
print(nmodc1$incr())
cat("Display Hobbs incr from nmodc1 as currently set:\n")
print(nmodh1$incr())
```

##  setVarying(vary = rep_len(TRUE, np))  

```{r tsetVarying(vary = rep_len(TRUE, np))  
cat("Display Croucher setVarying from nmodc1 as currently set:\n")
print(nmodc1$setVarying())
cat("Display Hobbs setVarying from nmodc1 as currently set:\n")
print(nmodh1$setVarying())
```

##  setPars(newPars)  

```{r tsetPars(newPars)  
cat("Display Croucher setPars(newPars) from nmodc1 as currently set:\n")
print(nmodc1$setPars(newPars)())
cat("Display Hobbs setPars(newPars) from nmodc1 as currently set:\n")
print(nmodh1$setPars(newPars)())
```

##  getPars()  

```{r tgetPars}  
cat("Display Croucher getPars from nmodc1 as currently set:\n")
print(nmodc1$fitted())
cat("Display Hobbs getPars from nmodc1 as currently set:\n")
print(nmodh1$getPars())
```

##  getAllPars()  

```{r tgetAllPars}  
cat("Display Croucher getAllPars from nmodc1 as currently set:\n")
print(nmodc1$getAllPars())
cat("Display Hobbs getAllPars from nmodc1 as currently set:\n")
print(nmodh1$getAllPars())
```

##  getEnv() 

```{r tgetEnv}
cat("Display Croucher fitted model values from nmodc1 as currently set:\n")
print(nmodc1$getEnv())
cat("Display Hobbs fitted model values from nmodc1 as currently set:\n")
print(nmodh1$getEnv())
```

##  trace() 

```{r ttrace} 
cat("Display Croucher trace from nmodc1 as currently set:\n")
print(nmodc1$trace())
cat("Display Hobbs trace from nmodc1 as currently set:\n")
print(nmodh1$trace())
```

##  Rmat()  

```{r tRmat}  
cat("Display Croucher Rmat from nmodc1 as currently set:\n")
print(nmodc1$Rmat())
cat("Display Hobbs Rmat from nmodc1 as currently set:\n")
print(nmodh1$Rmat())
```

##  predict(newdata = list(), qr = FALSE)  

```{r tpredict}  
cat("Display Croucher predict from nmodc1 as currently set:\n")
cat("first with no new parameters -- we get the fitted values\n")
print(nmodc1$predict())
cat("Now with some new data\n")
newcdata<-data.frame(xdata=0.1, ydata=1.1)
print(nmodc1$predict(newdata=newcdata))
cat("Display Hobbs predict from nmodc1 as currently set:\n")
cat("first with no new parameters -- we get the fitted values\n")
print(nmodh1$predict())
cat("Now with some new data\n")
newhdata<-data.frame(tt=c(13,14), y=c(120,200))
print(nmodh1$predict(newdata=newhdata))
```


# Discussion

Here we will look at some of the issues of using nlsModel. In particular, we will examine
how this function may need to be modified to make it easier to maintain and use.

# References
