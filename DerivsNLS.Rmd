---
title: "Jacobian Calculations for nls()"
author:
  - Arkajyoti Bhattacharjee, Indian Institute of Technology, Kanpur
  - John C. Nash, University of Ottawa, Canada
date: "26/05/2021"
output: pdf_document
---

<!-- - Heather Turner, University of Warwick, UK -->

```{r setup, include=FALSE}
rm(list=ls()) # clear the workspace for this document
knitr::opts_chunk$set(echo = TRUE)
## setup for this document
library(nlsr)  # So we have the analytic/symbolic derivatives
library(numDeriv) # numerical derivatives package
library(microbenchmark)  # timing

printsum <- function(xx){ print(summary(xx))} # May be needed
traceval  <-  TRUE  # traceval set TRUE to debug or give full history
#  Set to FALSE when we don't need extensive output
```

# Jacobians in nls()

`nls()` needs Jacobians calculated at the current set of trial nonlinear model
parameters to set up the Gauss-Newton equations. Unfortunately, `nls()` calls
the Jacobian the "gradient", and uses function `numericDerivs()` to compute them.
This document is an attempt to describe different ways to compute the Jacobian
for use in nls() and related software, and to evaluate the performance of these
approaches.

In evaluating performance, we need to know the conditions under which the evaluation
was conducted. Thus the computations included in this document, which is built using
`Rmarkdown`, are specific to the computer in which the document is processed. We
will add tables that give the results for different computing environments at the
bottom.

# An example problem

We will use the Hobbs weed infestation problem (@jncnm79, page 120).

```{r hobbsex}
# Data for Hobbs problem
ydat  <-  c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443, 
            38.558, 50.156, 62.948, 75.995, 91.972) # for testing
tdat  <-  seq_along(ydat) # for testing

# A simple starting vector -- must have named parameters for nlxb, nls, wrapnlsr.
start1  <-  c(b1=1, b2=1, b3=1)
eunsc  <-   y ~ b1/(1+b2*exp(-b3*tt))
str(eunsc)
# Can we convert a string form of this "model" to a formula
ceunsc <- " y ~ b1/(1+b2*exp(-b3*tt))"
str(ceunsc)

# Will be TRUE if we have made the conversion
print(as.formula(ceunsc)==eunsc)

## LOCAL DATA IN DATA FRAMES
weeddata1  <-  data.frame(y=ydat, tt=tdat)

## Now ready to try things out.

```

# Tools for Jacobians

## numericDeriv()

`numericDeriv` is the R function used by `nls()` to evaluate Jacobians for its Gauss-Newton
equations. The R source code is in the file `nls.R`. It calls a C function numeric_deriv
in `nls.c`. 



# Other tools for computing Jacobians

The package `numDeriv` includes a function `jacobian()` that acts on a user
function `resid()` to produce the Jacobian at a set of parameters by several
choices of approximation. 

The package `nlsr` has a function `model2rjfun()` that converts an expression
describing how the residual functions are computed into an R function that
computes the residuals at a particular set of parameters and sets the 
**attribute** "gradient" of the vector of residual values to the Jacobian at
the particular set of parameters. 

## Symbolic methods from `nlsr`

## `numDeriv` package

# Temporary inclusion of ExDerivs.R before separating

```
weedenv <- list2env(weeddata1)
## weedenv$b1 <- start1$b1
## Error in start1$b1 : $ operator is invalid for atomic vectors
weedenv$b1 <- start1[[1]]
weedenv$b2 <- start1[[2]]
weedenv$b3 <- start1[[3]]
ls.str(weedenv)
rexpr<-call("-",eunsc[[3]], eunsc[[2]])
r0<-eval(rexpr, weedenv)
cat("Sumsquares at 1,1,1 is ",sum(r0^2),"\n")

## Another way
ldata<-list2env(as.list(start1),envir=weedenv)
ldata
ls.str(ldata)
eval(rexpr,envir=ldata)

## How to get a model frame? Do we need it?

## Error in model.frame.default(eunsc, ldata) : variable lengths differ (found for 'b1')
mfeunsc<-model.frame(eunsc, ldata)

y<-ydat
tt<-tdat
b1<-1
b2<-1
b3<-1
## Error in model.frame.default(eunsc) : variable lengths differ (found for 'b1')
mfeunsc<-model.frame(eunsc)
get_all_vars(eunsc)
eval(eunsc, ldata)
str(mfeunsc)

## 2021-5-25 try derivatives
print(eunsc)
## nlsr::model2rjfun forms a function with gradient (jacobian) attribute
funsc <- model2rjfun(eunsc, start1, data=weeddata1) # from nlsr: creates a function
tmodel2rjfun <- microbenchmark(model2rjfun(eunsc, start1, data=weeddata1))
print(tmodel2rjfun)
print(funsc)
print(funsc(start1))
print(environment(funsc))
print(ls.str(environment(funsc)))
print(ls(environment(funsc)$data))
eval(eunsc, environment(funsc))
vfunsc<-funsc(start1)
print(vfunsc)
tfunsc<-microbenchmark(funsc(start1))
print(tfunsc)

# following gives an error "theta should be of type character"
nDfunsc<-try(numericDeriv(eunsc, start1, weeddata1))
print(nDfunsc)
print(start1)

theta <- c("b1", "b2", "b3")
# Following gives error
## Error in numericDeriv(eunsc, theta, weedenv) : 
## 'language' object cannot be coerced to type 'double'
nDfunsc<-try(numericDeriv(eunsc, theta, weedenv))
print(nDfunsc)
str(theta)
str(weedenv)
print(weedenv)
## try other ways
xeunsc<-expression(eunsc)
## Error in numericDeriv(xeunsc, theta, rho = weedenv) : 
## 'list' object cannot be coerced to type 'double'
nDfunsc<-try(numericDeriv(xeunsc, theta, rho=weedenv))
## Error in numericDeriv(funsc, theta, rho = weedenv) : 
##    cannot coerce type 'closure' to vector of type 'double'
nDfunsc<-try(numericDeriv(funsc, theta, rho=weedenv))

y<-weeddata1$y
tt<-weeddata1$tt
# variables now in local environment
## Error in numericDeriv(funsc, theta) : 
##    cannot coerce type 'closure' to vector of type 'double'
nDfunsc<-try(numericDeriv(funsc, theta))

## Error in numericDeriv(xeunsc, theta, rho = weedenv) : 
## 'list' object cannot be coerced to type 'double'
nDfunsc<-try(numericDeriv(xeunsc, theta))

# Error in formula.default(object, env = baseenv()) : invalid formula
nDfunsc<-try(numericDeriv(as.formula(xeunsc), theta))

formunsc<-formula(eunsc)
str(formunsc)
formunsc[1]
formunsc[2]
formunsc[3]

## Error in numericDeriv(formunsc[3], theta) : object 'b1' not found
nDfunsc<-try(numericDeriv(formunsc[3], theta))

b1<-1
b2<-1
b3<-1
## Error in numericDeriv(formunsc[3], theta) : attempt to apply non-function
nDfunsc<-try(numericDeriv(formunsc[3], theta))

## seems to work

ndeunsc<-numericDeriv(rexpr, theta, rho=weedenv)
print(ndeunsc)
print(sum(ndeunsc^2))
tndeunsc<-microbenchmark(ndeunsc<-numericDeriv(rexpr, theta, rho=weedenv))
print(tndeunsc)


res0<-model2rjfun(eunsc, start1, data=weeddata1, jacobian=FALSE)
res0(start1)
jeunsc<-jacobian(res0, start1)
jeunsc
tjeunsc<-microbenchmark(jeunsc<-jacobian(res0, start1))
print(tjeunsc)

jeunsc-attr(vfunsc,"gradient")
attr(ndeunsc, "gradient")-attr(vfunsc,"gradient")

ndeunsc2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE)
print(ndeunsc2)
print(sum(ndeunsc2^2))
tndeunsc2<-microbenchmark(ndeunsc2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE))
print(tndeunsc2)
attr(ndeunsc2, "gradient")-attr(vfunsc,"gradient")

ndeunscx<-numericDeriv(rexpr, theta, rho=weedenv, eps=1e-10)
print(ndeunscx)
print(sum(ndeunscx^2))
tndeunscx<-microbenchmark(ndeunscx<-numericDeriv(rexpr, theta, rho=weedenv, eps=1e-10))
print(tndeunscx)
attr(ndeunscx, "gradient")-attr(vfunsc,"gradient")

ndeunscx2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE, eps=1e-10)
print(ndeunscx2)
print(sum(ndeunscx2^2))
tndeunscx2<-microbenchmark(ndeunscx2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE, eps=1e-10))
print(tndeunscx2)
attr(ndeunscx2, "gradient")-attr(vfunsc,"gradient")

## We have not tried the dir parameter (probably allows backward differences)

```

# Performance results for different computing environments

Here we present tables of the results, preceded by identified descriptions of the machines we
used.

M21-LM20.1 

```{r M21desc}
sessionInfo()
```

To get a good picture of the physical and logical machine that is M21-LM20.1, we can
run

```
inxi -F >tlinux.txt
```

in a command line terminal in the host machine. 

While it may be tempting to run either

```{r runinxi}
system('inxi -F >t.txt')
```

or 

```{bash inxi2}
inxi -F >t2.txt
```

it turns out that the encoding of the files is different. Indeed
the files are different sizes!

```{bash ls-t}
ls -al t*.txt
```
Here is the result from running the `inxi` command in the native Linux
terminal.

```{r M21disp}
cat(readLines('tlinuxOS.txt'), sep = '\n')
```

