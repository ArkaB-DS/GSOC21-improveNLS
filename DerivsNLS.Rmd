---
title: "Jacobian Calculations for nls()"
author:
  - Arkajyoti Bhattacharjee, Indian Institute of Technology, Kanpur
  - John C. Nash, University of Ottawa, Canada
date: "26/05/2021"
output: pdf_document
bibliography: ImproveNLS.bib
---

<!-- - Heather Turner, University of Warwick, UK -->

```{r setup, include=FALSE}
rm(list=ls()) # clear the workspace for this document
knitr::opts_chunk$set(echo = TRUE)
## setup for this document
library(nlsr)  # So we have the analytic/symbolic derivatives
library(numDeriv) # numerical derivatives package
library(microbenchmark)  # timing

printsum <- function(xx){ print(summary(xx))} # May be needed
traceval  <-  TRUE  # traceval set TRUE to debug or give full history
#  Set to FALSE when we don't need extensive output
```

# Jacobians in nls()

`nls()` needs Jacobians calculated at the current set of trial nonlinear model
parameters to set up the Gauss-Newton equations. Unfortunately, `nls()` calls
the Jacobian the "gradient", and uses function `numericDerivs()` to compute them.
This document is an attempt to describe different ways to compute the Jacobian
for use in nls() and related software, and to evaluate the performance of these
approaches.

In evaluating performance, we need to know the conditions under which the evaluation
was conducted. Thus the computations included in this document, which is built using
`Rmarkdown`, are specific to the computer in which the document is processed. We
will add tables that give the results for different computing environments at the
bottom.

# An example problem

We will use the Hobbs weed infestation problem (@jncnm79, page 120).

```{r hobbsex}
# Data for Hobbs problem
ydat  <-  c(5.308, 7.24, 9.638, 12.866, 17.069, 23.192, 31.443, 
            38.558, 50.156, 62.948, 75.995, 91.972) # for testing
tdat  <-  seq_along(ydat) # for testing

# A simple starting vector -- must have named parameters for nlxb, nls, wrapnlsr.
start1  <-  c(b1=1, b2=1, b3=1)
eunsc  <-   y ~ b1/(1+b2*exp(-b3*tt))
str(eunsc)
# Can we convert a string form of this "model" to a formula
ceunsc <- " y ~ b1/(1+b2*exp(-b3*tt))"
str(ceunsc)

# Will be TRUE if we have made the conversion
print(as.formula(ceunsc)==eunsc)

## LOCAL DATA IN DATA FRAMES
weeddata1  <-  data.frame(y=ydat, tt=tdat)

## Put data in an Environment
weedenv <- list2env(weeddata1)
weedenv$b1 <- start1[[1]]
weedenv$b2 <- start1[[2]]
weedenv$b3 <- start1[[3]]
# Display content of the Environment
## Note that may need to do further commands to get everything
ls.str(weedenv)
# Generate the residual "call"
rexpr<-call("-",eunsc[[3]], eunsc[[2]])
# Get the residuals
r0<-eval(rexpr, weedenv)
print(r0)
cat("Sumsquares at 1,1,1 is ",sum(r0^2),"\n")

## Another way
ldata<-list2env(as.list(start1),envir=weedenv)
ldata
ls.str(ldata)
eval(rexpr,envir=ldata)

## Do we need to get a model frame? How? and How to use it?

## Now ready to try things out.
```

# Tools for Jacobians

## numericDeriv()

`numericDeriv` is the R function used by `nls()` to evaluate Jacobians for its Gauss-Newton
equations. The R source code is in the file `nls.R`. It calls a C function numeric_deriv
in `nls.c`. 

```{r nD1}
## seems to work -- Note file ExDerivs.R has many "failures"
theta <- c("b1", "b2", "b3")
ndeunsc<-numericDeriv(rexpr, theta, rho=weedenv)
print(ndeunsc)
print(sum(ndeunsc^2))
tndeunsc<-microbenchmark(ndeunsc<-numericDeriv(rexpr, theta, rho=weedenv))
print(tndeunsc)
## numericDeriv also has central difference option, as well as choice of eps parameter
## Central diff
ndeunsc2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE)
print(ndeunsc2)
print(sum(ndeunsc2^2))
tndeunsc2<-microbenchmark(ndeunsc2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE))
print(tndeunsc2)

## Forward diff with smaller eps
ndeunscx<-numericDeriv(rexpr, theta, rho=weedenv, eps=1e-10)
print(ndeunscx)
print(sum(ndeunscx^2))
tndeunscx<-microbenchmark(ndeunscx2<-numericDeriv(rexpr, theta, rho=weedenv, eps=1e-10))
print(tndeunscx)

## Central diff with smaller eps
ndeunscx2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE, eps=1e-10)
print(ndeunscx2)
print(sum(ndeunscx2^2))
tndeunscx2<-microbenchmark(ndeunscx2<-numericDeriv(rexpr, theta, rho=weedenv, central=TRUE, eps=1e-10))
print(tndeunscx2)


```

**We have not tried the dir parameter (probably allows backward differences)**


## Symbolic methods from `nlsr`

The package `nlsr` has a function `model2rjfun()` that converts an expression
describing how the residual functions are computed into an R function that
computes the residuals at a particular set of parameters and sets the 
**attribute** "gradient" of the vector of residual values to the Jacobian at
the particular set of parameters. 

```{r nlsr1}
# nlsr has function model2rjfun. We can evaluate just the residuals
res0<-model2rjfun(eunsc, start1, data=weeddata1, jacobian=FALSE)
res0(start1)
# or the residuals and jacobian
## nlsr::model2rjfun forms a function with gradient (jacobian) attribute
funsc <- model2rjfun(eunsc, start1, data=weeddata1) # from nlsr: creates a function
tmodel2rjfun <- microbenchmark(model2rjfun(eunsc, start1, data=weeddata1))
print(tmodel2rjfun)
print(funsc)
print(funsc(start1))
print(environment(funsc))
print(ls.str(environment(funsc)))
print(ls(environment(funsc)$data))
eval(eunsc, environment(funsc))
vfunsc<-funsc(start1)
print(vfunsc)
tfunsc<-microbenchmark(funsc(start1))
print(tfunsc)
```

# `numDeriv` package

The package `numDeriv` includes a function `jacobian()` that acts on a user
function `resid()` to produce the Jacobian at a set of parameters by several
choices of approximation. 

```{r numDeriv1}
# We use the residual function (without gradient attribute) from nlsr
jeunsc<-jacobian(res0, start1)
jeunsc
tjeunsc<-microbenchmark(jeunsc<-jacobian(res0, start1))
print(tjeunsc)
```

Note that the manual pages for `numDeriv` offer many options for the functions in
the package. At 2021-5-27 we have yet to explore these.

# Comparisons

In the following, we are comparing to `vfunsc`, which is the evaluated 
residual vector at `start1=c(1,1,1)` with "gradient" attribute (jacobian)
included, as developed using package `nlsr`. This is taken as the "correct"
result.

`numericDeriv` computes a similar structure (residuals with "gradient" attribute):
`ndeunsc`: the forward difference result with default `eps` (1e-07 according to manual)
`ndeunsc2`: Central difference with default `eps`
`ndeunscx`: Forward difference with smaller eps=1e-10
`ndeunscx2`: Central difference with smaller eps=1e-10

`jeunsc`: numDeriv::jacobian() result with default settings.

```{r compjac1}
## Matrix comparisons
attr(ndeunsc, "gradient")-attr(vfunsc,"gradient")
attr(ndeunsc2, "gradient")-attr(vfunsc,"gradient")
attr(ndeunscx, "gradient")-attr(vfunsc,"gradient")
attr(ndeunscx2, "gradient")-attr(vfunsc,"gradient")
jeunsc-attr(vfunsc,"gradient")

## Summary comparisons
max(abs(attr(ndeunsc, "gradient")-attr(vfunsc,"gradient")))
max(abs(attr(ndeunsc2, "gradient")-attr(vfunsc,"gradient")))
max(abs(attr(ndeunscx, "gradient")-attr(vfunsc,"gradient")))
max(abs(attr(ndeunscx2, "gradient")-attr(vfunsc,"gradient")))
max(abs(jeunsc-attr(vfunsc,"gradient")))
```



# Performance results for different computing environments

Here we present tables of the results, preceded by identified descriptions of the machines we
used.

M21-LM20.1 

```{r M21desc}
sessionInfo()
```

To get a good picture of the physical and logical machine that is M21-LM20.1, we can
run

```
inxi -F >tlinux.txt
```

in a command line terminal in the host machine. 

While it may be tempting to run either

```{r runinxi}
system('inxi -F >../t.txt')
```

or 

```{bash inxi2}
inxi -F >../t2.txt
```

it turns out that the encoding of the files is different. Indeed
the files are different sizes!

```{bash ls-t}
ls -al ../t*.txt
```
Here is the result from running the `inxi` command in the native Linux
terminal. (?? note that we need each "user to do following.) Note that
the file tlinuxOS.txt needs to be created via the command

```
inxi -F > tlinuxOS.txt
```

in the directory immediately ABOVE the `improvenls` local git repository where
the present docoument is stored i.e., outside the version control. 

```{r M21disp}
cat(readLines('../tlinuxOS.txt'), sep = '\n')
```

```
#!/bin/sh
inxi -F >../tlx.txt
echo "done!"
```


```{r M21mt1}
system("mate-terminal -e ./inxirun.sh")
cat(readLines('../tlx.txt'), sep = '\n')
```

## Appendix 1: Base R numericDeriv code

This code is in two files, nls.R and nls.c and is extracted here.

### From nls.R

```
numericDeriv <- function(expr, theta, rho = parent.frame(), dir = 1,
                 eps = .Machine$double.eps ^ (1/if(central) 3 else 2), central = FALSE)
## Note: this expr must be set up as a call to work properly according to JN??
## ?? we set eps conditional on central. But central set AFTER eps. Is this OK.
{    cat("numericDeriv-Alt\n")
    dir <- rep_len(dir, length(theta))
    stopifnot(is.finite(eps), eps > 0)
    rho1 <- new.env(FALSE, rho, 0)
    if (!is.character(theta) ) {stop("'theta' should be of type character")}
    if (is.null(rho)) {
            stop("use of NULL environment is defunct")
            #        rho <- R_BaseEnv;
    } else {
          if(! is.environment(rho)) {stop("'rho' should be an environment")}
          #    int nprot = 3;
    }
    if( ! ((length(dir) == length(theta) ) & (is.numeric(dir) ) ) )
              {stop("'dir' is not a numeric vector of the correct length") }
    if(is.na(central)) { stop("'central' is NA, but must be TRUE or FALSE") }
    res0 <- eval(expr, rho) # the base residuals. ?? C has a check for REAL ANS=res0
    if (any(is.infinite(res0)) ) {stop("residuals cannot be evaluated at base point")}
    ##  CHECK_FN_VAL(res, ans);  ?? how to do this. Is it necessary?
    nt <- length(theta) # number of parameters
    mr <- length(res0) # number of residuals
    JJ <- matrix(NA, nrow=mr, ncol=nt) # Initialize the Jacobian
    for (j in 1:nt){
       origPar<-get(theta[j],rho)
       xx <- abs(origPar)
       delta <- if (xx == 0.0) {eps} else { xx*eps }
       ## JN: I prefer eps*(xx + eps)  which is simpler ?? Should we suggest / use a control switch
       prmx<-origPar+delta*dir[j]
       assign(theta[j],prmx,rho)
       res1 <- eval(expr, rho) # new residuals (forward step)
       if (central) { # compute backward step resids for central diff
          prmb <- origPar - dir[j]*delta
          assign(theta[j], prmb, envir=rho) # may be able to make more efficient later??
          resb <- eval(expr, rho)
          JJ[, j] <- dir[j]*(res1-resb)/(2*delta) # vectorized
       } else { ## forward diff
          JJ[,j] <- dir[j]*(res1-res0)/delta
       }  # end forward diff
    } # end loop over the parameters
    attr(res0, "gradient") <- JJ
    return(res0)
}

```

### From nls.c

```
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include <R.h>
#include <Rinternals.h>
#include "nls.h"
#include "internals.h"

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif

/*
 *  call to numeric_deriv from R -
 *  .Call("numeric_deriv", expr, theta, rho, dir = 1., eps = .Machine$double.eps, central=FALSE)
 *  Returns: ans
 */
SEXP
numeric_deriv(SEXP expr, SEXP theta, SEXP rho, SEXP dir, SEXP eps_, SEXP centr,
              SEXP rho1)
{
    if(!isString(theta))
	error(_("'theta' should be of type character"));
    if (isNull(rho)) {
	error(_("use of NULL environment is defunct"));
	rho = R_BaseEnv;
    } else
	if(!isEnvironment(rho))
	    error(_("'rho' should be an environment"));
    int nprot = 3;
    if(TYPEOF(dir) != REALSXP) {
	PROTECT(dir = coerceVector(dir, REALSXP)); nprot++;
    }
    if(LENGTH(dir) != LENGTH(theta))
	error(_("'dir' is not a numeric vector of the correct length"));
    Rboolean central = asLogical(centr);
    if(central == NA_LOGICAL)
	error(_("'central' is NA, but must be TRUE or FALSE"));
//    SEXP rho1 = PROTECT(R_NewEnv(rho, FALSE, 0));
//    nprot++;
    SEXP
	pars = PROTECT(allocVector(VECSXP, LENGTH(theta))),
        ans  = PROTECT(duplicate(eval(expr, rho1)));
    double *rDir = REAL(dir),  *res = NULL; // -Wall
#define CHECK_FN_VAL(_r_, _ANS_) do {					\
    if(!isReal(_ANS_)) {						\
	SEXP temp = coerceVector(_ANS_, REALSXP);			\
	UNPROTECT(1);/*: _ANS_ *must* have been the last PROTECT() ! */ \
	PROTECT(_ANS_ = temp);						\
    }									\
    _r_ = REAL(_ANS_);							\
    for(int i = 0; i < LENGTH(_ANS_); i++) {				\
	if (!R_FINITE(_r_[i]))						\
	    error(_("Missing value or an infinity produced when evaluating the model")); \
    }									\
} while(0)

    CHECK_FN_VAL(res, ans);

    const void *vmax = vmaxget();
    int lengthTheta = 0;
    for(int i = 0; i < LENGTH(theta); i++) {
	const char *name = translateChar(STRING_ELT(theta, i));
	SEXP s_name = install(name);
	SEXP temp = findVar(s_name, rho1);
	if(isInteger(temp))
	    error(_("variable '%s' is integer, not numeric"), name);
	if(!isReal(temp))
	    error(_("variable '%s' is not numeric"), name);
	// We'll be modifying the variable, so need to make a copy PR#15849
	defineVar(s_name, temp = duplicate(temp), rho1);
	MARK_NOT_MUTABLE(temp);
	SET_VECTOR_ELT(pars, i, temp);
	lengthTheta += LENGTH(VECTOR_ELT(pars, i));
    }
    vmaxset(vmax);
    SEXP gradient = PROTECT(allocMatrix(REALSXP, LENGTH(ans), lengthTheta));
    double *grad = REAL(gradient);
    double eps = asReal(eps_); // was hardcoded sqrt(DOUBLE_EPS) { ~= 1.49e-08, typically}
    for(int start = 0, i = 0; i < LENGTH(theta); i++) {
	double *pars_i = REAL(VECTOR_ELT(pars, i));
	for(int j = 0; j < LENGTH(VECTOR_ELT(pars, i)); j++, start += LENGTH(ans)) {
	    double
		origPar = pars_i[j],
		xx = fabs(origPar),
		delta = (xx == 0) ? eps : xx*eps;
	    pars_i[j] += rDir[i] * delta;
	    SEXP ans_del = PROTECT(eval(expr, rho1));
	    double *rDel = NULL;
	    CHECK_FN_VAL(rDel, ans_del);
	    if(central) {
		pars_i[j] = origPar - rDir[i] * delta;
		SEXP ans_de2 = PROTECT(eval(expr, rho1));
		double *rD2 = NULL;
		CHECK_FN_VAL(rD2, ans_de2);
		for(int k = 0; k < LENGTH(ans); k++) {
		    grad[start + k] = rDir[i] * (rDel[k] - rD2[k])/(2 * delta);
		}
	    } else { // forward difference  (previously hardwired):
		for(int k = 0; k < LENGTH(ans); k++) {
		    grad[start + k] = rDir[i] * (rDel[k] - res[k])/delta;
		}
	    }
	    UNPROTECT(central ? 2 : 1); // ansDel & possibly ans
	    pars_i[j] = origPar;
	}
    }
    setAttrib(ans, install("gradient"), gradient);
    UNPROTECT(nprot);
    return ans;
}

## Appendix 2: numericDeriv() from nlsalt package (all in R)

```
numericDeriv <- function(expr, theta, rho = parent.frame(), dir = 1,
                 eps = .Machine$double.eps ^ (1/if(central) 3 else 2), central = FALSE)
## Note: this expr must be set up as a call to work properly according to JN??
## ?? we set eps conditional on central. But central set AFTER eps. Is this OK.
{    cat("numericDeriv-Alt\n")
    dir <- rep_len(dir, length(theta))
    stopifnot(is.finite(eps), eps > 0)
    rho1 <- new.env(FALSE, rho, 0)
    if (!is.character(theta) ) {stop("'theta' should be of type character")}
    if (is.null(rho)) {
            stop("use of NULL environment is defunct")
            #        rho <- R_BaseEnv;
    } else {
          if(! is.environment(rho)) {stop("'rho' should be an environment")}
          #    int nprot = 3;
    }
    if( ! ((length(dir) == length(theta) ) & (is.numeric(dir) ) ) )
              {stop("'dir' is not a numeric vector of the correct length") }
    if(is.na(central)) { stop("'central' is NA, but must be TRUE or FALSE") }
    res0 <- eval(expr, rho) # the base residuals. ?? C has a check for REAL ANS=res0
    if (any(is.infinite(res0)) ) {stop("residuals cannot be evaluated at base point")}
    ##  CHECK_FN_VAL(res, ans);  ?? how to do this. Is it necessary?
    nt <- length(theta) # number of parameters
    mr <- length(res0) # number of residuals
    JJ <- matrix(NA, nrow=mr, ncol=nt) # Initialize the Jacobian
    for (j in 1:nt){
       origPar<-get(theta[j],rho)
       xx <- abs(origPar)
       delta <- if (xx == 0.0) {eps} else { xx*eps }
       ## JN: I prefer eps*(xx + eps)  which is simpler ?? Should we suggest / use a control switch
       prmx<-origPar+delta*dir[j]
       assign(theta[j],prmx,rho)
       res1 <- eval(expr, rho) # new residuals (forward step)
       if (central) { # compute backward step resids for central diff
          prmb <- origPar - dir[j]*delta
          assign(theta[j], prmb, envir=rho) # may be able to make more efficient later??
          resb <- eval(expr, rho)
          JJ[, j] <- dir[j]*(res1-resb)/(2*delta) # vectorized
       } else { ## forward diff
          JJ[,j] <- dir[j]*(res1-res0)/delta
       }  # end forward diff
    } # end loop over the parameters
    attr(res0, "gradient") <- JJ
    return(res0)
}
```


```