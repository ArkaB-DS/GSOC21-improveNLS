
R version 4.1.0 (2021-05-18) -- "Camp Pontanezen"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #  File src/library/stats/tests/nlsj.R
> #  Part of the R package, https://www.R-project.org
> #
> #  This program is free software; you can redistribute it and/or modify
> #  it under the terms of the GNU General Public License as published by
> #  the Free Software Foundation; either version 2 of the License, or
> #  (at your option) any later version.
> #
> #  This program is distributed in the hope that it will be useful,
> #  but WITHOUT ANY WARRANTY; without even the implied warranty of
> #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> #  GNU General Public License for more details.
> #
> #  A copy of the GNU General Public License is available at
> #  https://www.R-project.org/Licenses/
> 
> ## tests of nlsj, especially of weighted fits
> library(nlsj) # ??added 210716 JN

Attaching package: 'nlsj'

The following object is masked from 'package:stats':

    numericDeriv

> 
> library(stats)
> options(digits = 5) # to avoid trivial printed differences
> options(useFancyQuotes = FALSE) # avoid fancy quotes in o/p
> options(show.nlsj.convergence = FALSE) # avoid non-diffable output
> options(warn = 1)
> 
> have_MASS <- requireNamespace('MASS', quietly = TRUE)
> 
> pdf("nlsj-test.pdf")
> 
> ## utility for comparing nlsj() results:  [TODO: use more often below]
> .n <- function(r) r[names(r) != "call"]
> 
> ## selfStart.default() w/ no parameters:
> logist <- deriv( ~Asym/(1+exp(-(x-xmid)/scal)), c("Asym", "xmid", "scal"),
+ 		function(x, Asym, xmid, scal){} )
> logistInit <- function(mCall, LHS, data) {
+     xy <- sortedXyData(mCall[["x"]], LHS, data)
+     if(nrow(xy) < 3) stop("Too few distinct input values to fit a logistic")
+     Asym <- max(abs(xy[,"y"]))
+     if (Asym != max(xy[,"y"])) Asym <- -Asym  # negative asymptote
+     xmid <- NLSstClosestX(xy, 0.5 * Asym)
+     scal <- NLSstClosestX(xy, 0.75 * Asym) - xmid
+     setNames(c(Asym, xmid, scal),
+ 	     mCall[c("Asym", "xmid", "scal")])
+ }
> logist <- selfStart(logist, initial = logistInit) ##-> Error in R 1.5.0
> str(logist)
function (x, Asym, xmid, scal)  
 - attr(*, "initial")=function (mCall, LHS, data)  
 - attr(*, "class")= chr "selfStart"
> 
> ## lower and upper in algorithm="port" ?? Won't use port for now 210716, but put in bounds
> set.seed(123)
> x <- runif(200)
> a <- b <- 1; c <- -0.1
> y <- a+b*x+c*x^2+rnorm(200, sd=0.05)
> plot(x,y)
> curve(a+b*x+c*x^2, add = TRUE)
> ## IGNORE_RDIFF_BEGIN ## nlsj does not call "port" (yet??)
> ## nlsj(y ~ a+b*x+c*I(x^2), start = c(a=1, b=1, c=0.1), algorithm = "port")
> nlsj(y ~ a+b*x+c*I(x^2), start = c(a=1, b=1, c=0.1))
Warning in nlsj(y ~ a + b * x + c * I(x^2), start = c(a = 1, b = 1, c = 0.1)) :
  Forcing numericDeriv
Warning in nlsj(y ~ a + b * x + c * I(x^2), start = c(a = 1, b = 1, c = 0.1)) :
  Data is not declared explicitly. Caution!
[1]  0.0058361 -0.0176092 -0.1897204
1  bdmsk= 1   delta= 0.0058361 
2  bdmsk= 1   delta= -0.017609 
3  bdmsk= 1   delta= -0.18972 
fac before = 1  after= 1 
fac= 1  ssnew=0.46041 
Nonlinear regression model
  model: y ~ a + b * x + c * I(x^2)
   data: NULL
      a       b       c 
 1.0058  0.9824 -0.0897 
 residual sum-of-squares: 0.46
[1] TRUE
attr(,"cmsg")
[1] "Termination msg:  Relative offset less than  1e-05 &&"
attr(,"ctol")
[1] 1.3038e-07
attr(,"nres")
[1] 2
attr(,"njac")
[1] 3
> # ?? (fm <- nlsj(y ~ a+b*x+c*I(x^2), start = c(a=1, b=1, c=0.1),
> # ??           algorithm = "port", lower = c(0, 0, 0)))
> ## IGNORE_RDIFF_END
> # ??if(have_MASS) {
> # ??    print(confint(fm))
> # ??} else message("skipping tests requiring the MASS package")
> 
> ## weighted nlsj fit
> set.seed(123)
> y <- x <- 1:10
> yeps <- y + rnorm(length(y), sd = 0.01)
> wts <- rep(c(1, 2), length = 10); wts[5] <- 0
> fit0 <- lm(yeps ~ x, weights = wts)
> ## IGNORE_RDIFF_BEGIN
> summary(fit0, cor = TRUE)

Call:
lm(formula = yeps ~ x, weights = wts)

Weighted Residuals:
     Min       1Q   Median       3Q      Max 
-0.01562 -0.00723 -0.00158  0.00403  0.02413 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  0.00517    0.00764    0.68     0.52    
x            0.99915    0.00119  841.38   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0132 on 7 degrees of freedom
Multiple R-squared:     1,	Adjusted R-squared:     1 
F-statistic: 7.08e+05 on 1 and 7 DF,  p-value: <2e-16

Correlation of Coefficients:
  (Intercept)
x -0.89      

> cf0 <- coef(summary(fit0))[, 1:2]
> fit <- nlsj(yeps ~ a + b*x, start = list(a = 0.12345, b = 0.54321),  weights = wts, trace = TRUE)
Warning in nlsj(yeps ~ a + b * x, start = list(a = 0.12345, b = 0.54321),  :
  Forcing numericDeriv
nlsj: Using default algorithm
Warning in nlsj(yeps ~ a + b * x, start = list(a = 0.12345, b = 0.54321),  :
  Data is not declared explicitly. Caution!
lhs has just the variable  yeps 
  1 / 2  112.14 :(0.12345  0.54321  )  rofftest= 304.08 
[1] -0.11828  0.45594
1  bdmsk= 1   delta= -0.11828 
2  bdmsk= 1   delta= 0.45594 
fac before = 1  after= 1 
fac= 1  ssnew=0.0012128 
<  2 / 3  0.0012128 :(0.0051705  0.99915  )  rofftest= 3.1976e-06 
> summary(fit, cor = TRUE)

Formula: yeps ~ a + b * x

Parameters:
  Estimate Std. Error t value Pr(>|t|)    
a  0.00517    0.00764    0.68     0.52    
b  0.99915    0.00119  841.38   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0132 on 7 degrees of freedom

Correlation of Parameter Estimates:
  a    
b -0.89
[1] TRUE
attr(,"cmsg")
[1] "Termination msg:  Relative offset less than  1e-05 &&"
attr(,"ctol")
[1] 3.1976e-06
attr(,"nres")
[1] 2
attr(,"njac")
[1] 3

> df <- data.frame(x=x, yeps=yeps)
> ## IGNORE WHEN RUNNING R CMD check since needs external pkg
> ## fit2 <- nlsr::nlxb(yeps ~ a + b*x, start = list(a = 0.12345, b = 0.54321), data=df,  weights = wts, trace = TRUE)
> fitn <- nls(yeps ~ a + b*x, start = list(a = 0.12345, b = 0.54321), weights = wts, trace = TRUE)
112.14    (3.04e+02): par = (0.12345 0.54321)
0.0012128 (3.20e-06): par = (0.0051705 0.99915)
> ## IGNORE_RDIFF_END
> stopifnot(all.equal(residuals(fit), residuals(fit0), tolerance = 1e-5,
+                     check.attributes = FALSE))
> stopifnot(df.residual(fit) == df.residual(fit0))
> stopifnot(all.equal(logLik(fit), logLik(fit0), tolerance = 1e-8))
> cf1 <- coef(summary(fit))[, 1:2]
> ## IGNORE_RDIFF_BEGIN
> fit2 <- nlsj(yeps ~ a + b*x, start = list(a = 0.12345, b = 0.54321),
+             weights = wts, trace = TRUE, algorithm = "port")
Warning in nlsj(yeps ~ a + b * x, start = list(a = 0.12345, b = 0.54321),  :
  Forcing numericDeriv
nlsj: Using default algorithm
Warning in nlsj(yeps ~ a + b * x, start = list(a = 0.12345, b = 0.54321),  :
  Data is not declared explicitly. Caution!
lhs has just the variable  yeps 
  1 / 2  112.14 :(0.12345  0.54321  )  rofftest= 304.08 
[1] -0.11828  0.45594
1  bdmsk= 1   delta= -0.11828 
2  bdmsk= 1   delta= 0.45594 
fac before = 1  after= 1 
fac= 1  ssnew=0.0012128 
<  2 / 3  0.0012128 :(0.0051705  0.99915  )  rofftest= 3.1976e-06 
> summary(fit2, cor = TRUE)

Formula: yeps ~ a + b * x

Parameters:
  Estimate Std. Error t value Pr(>|t|)    
a  0.00517    0.00764    0.68     0.52    
b  0.99915    0.00119  841.38   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.0132 on 7 degrees of freedom

Correlation of Parameter Estimates:
  a    
b -0.89
[1] TRUE
attr(,"cmsg")
[1] "Termination msg:  Relative offset less than  1e-05 &&"
attr(,"ctol")
[1] 3.1976e-06
attr(,"nres")
[1] 2
attr(,"njac")
[1] 3

> ## IGNORE_RDIFF_END
> cf2 <- coef(summary(fit2))[, 1:2]
> rownames(cf0) <- c("a", "b")
> # expect relative errors ca 2e-08
> stopifnot(all.equal(cf1, cf0, tolerance = 1e-6),
+           all.equal(cf1, cf0, tolerance = 1e-6))
> stopifnot(all.equal(residuals(fit2), residuals(fit0), tolerance = 1e5,
+                     check.attributes = FALSE))
> stopifnot(all.equal(logLik(fit2), logLik(fit0), tolerance = 1e-8))
> 
> 
> DNase1 <- subset(DNase, Run == 1)
> DNase1$wts <- rep(8:1, each = 2)
> fm1 <- nlsj(density ~ SSlogis(log(conc), Asym, xmid, scal),
+            data = DNase1, weights = DNase1$wts)
Warning in nlsj(density ~ SSlogis(log(conc), Asym, xmid, scal), data = DNase1,  :
  Forcing numericDeriv
Error in nlsj(density ~ SSlogis(log(conc), Asym, xmid, scal), data = DNase1,  : 
  argument "start" is missing, with no default
Execution halted
